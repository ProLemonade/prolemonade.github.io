<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>He's approaching!!!</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;

            -webkit-touch-callout: none;
            -webkit-user-select: none;  
            
            user-select: none;  
            touch-action: manipulation; 

        }

        body {
            width: 100vw;
            height: 100vh;
            min-width: 420px;
            background: #0a0a0a;
            font-family: 'Press Start 2P', monospace;
            image-rendering: pixelated;
            overflow: hidden;
        }
        .safe-area-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            padding-bottom: env(safe-area-inset-bottom);
            overflow: hidden;
}
        #gameCanvas {
            width: 100%;
            height: 100%;
            position: relative;
            background: linear-gradient(180deg, #001122 0%, #000511 100%);
        }



        #healthBar {
            position: absolute;
            top: 0px;
            left: 5px;
        }
        #healthBar img {
            height: 85px;
            width: auto;
        }


        #scoreContainer {
            position: absolute;
            top: 40px;
            right: 15px;
            text-align: right;
            color: #ffffff;
        }
        .label {
            font-size: 14px;
            color: #cccccc;
            display: block;
            margin-bottom: 20px;
        }
        #score {
            font-size: 20px;
            color: #ffff00;
        }



        #bossContainer {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
        }
        #bossContainer img {
            height: 100px;
            width: auto;
        }

        #playerContainer {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
        }
        #playerContainer img {
            height: 100px;
            width: auto;
        }

        @media (max-width: 510px) {

            #bossContainer {
                left: 250px;
                top: 50px;
            }

            #fireContainer {
                left: 250px;
            }
        }



        .event-icons {
            position: absolute;
            top: 80px;
            left: 20px;
            display: flex;
            gap: 12px;
        }
        .event-icon {
            position: relative;
            width: 50px;
            height: 50px;
        }
        .event-icon img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .cooldown-mask {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background: rgba(0, 0, 0, 0.5);
            transition: height 0.1s linear;
            pointer-events: none;
        }
        .event-icon.ready {
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }



        #controls {
            position: fixed;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            pointer-events: auto;
        }
        .control-btn {
            width: 80px;
            height: 80px;
            background-color: transparent;
            background-size: contain;
            border: none;
            outline: none;
            opacity: 0.9;
            transition: opacity 0.2s;
            pointer-events: auto;
        }
        #leftBtn {
            background-image: url('./images/left.png');
        }
        #rightBtn {
            background-image: url('./images/right.png');
        }
        .control-btn:active {
            opacity: 0.5;
        }



        #gameStart {
            display: block;
        }
        #gameOver {
            display: none;
        }


        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            background: #000c;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            text-align: center;
            color: #fff;
            font-family: 'Press Start 2P', monospace;
            z-index: 999;
        }
        .center-wrapper {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            min-width: 300px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .modal-title {
            color: #ffff00;
            font-size: 18px;
            margin-bottom: 5px;
        }
        .modal-button {
            padding: 10px 20px;
            margin-top: 10px;
            font-size: 14px;
            font-family: 'Press Start 2P', monospace;
            background: #222;
            color: #fff;
            border: 2px solid #fff;
            cursor: pointer;

            width: 150px;
            display: block;
            margin-left: auto;
            margin-right: auto;

        }
        .infinite {
            font-size: 30px;
            color: #ff3333;
        }










    </style>
</head>
<body>
    <div class="safe-area-container"> 
    <canvas id="gameCanvas"></canvas>

    <div id="gameUI">
        <div id="healthBar">
                <img src="./images/Blood3.PNG" id="bloodImage">
        </div>

        <div id="scoreContainer">
            <span class="label">SCORES</span>
            <span id="score">000000</span>
        </div>

        <div id="bossContainer">
            <img src="./images/BOSS.PNG" alt="Boss" id="bossImage">
        </div>

        <div id="playerContainer">
            <img src="./images/FireN.PNG" alt=Fire>
        </div>


        <div class="event-icons">
            <div class="event-icon" id="eventFlash">
                <img src="./images/EventFlash.PNG" alt="Flash">
                <div class="cooldown-mask"></div>
            </div>
            <div class="event-icon" id="eventSpike">
                <img src="./images/EventStrike.PNG" alt="Strike">
                <div class="cooldown-mask"></div>
            </div>
            <div class="event-icon" id="eventProjectile">
                <img src="./images/EventBullet.PNG" alt="Bullet">
                <div class="cooldown-mask"></div>
            </div>
        </div>

    </div>

    <div class="buff-icon" id="buffIcons"></div>

    <div id="controls">
        <button class="control-btn" id="leftBtn"></button>
        <button class="control-btn" id="rightBtn"></button>
    </div>
    <!-- æ¸¸æˆå¼€å§‹å¼¹çª— -->
    <div id="gameStart" class="modal">
        <div class="center-wrapper">
            <div class="modal-title">Score as much as you can</div>
            <div class="modal-title">before <span class="infinite">âˆ</span> comes.</div>
            <button id="startBtn" class="modal-button">START</button>
        </div>
    </div>
    <!-- æ¸¸æˆç»“æŸå¼¹çª— -->
    <div id="gameOver" class="modal">
        <div class="center-wrapper">
            <div id="gameOverReason" class="modal-title"></div>
            <div class="modal-title" style="padding: 10px;">
                <p>Final Score: <span id="finalScore">000000</span></p>
            </div>
            <button id="restartBtn" class="modal-button">RESTART</button>
        </div>
    </div>
    </div>
    <script>
        // ============= æ¸¸æˆé…ç½® =============
        const CONFIG = {
            GAME_DURATION: 60000, // æ¸¸æˆæ—¶é•¿(ms) - Bossåˆ°è¾¾æ—¶é—´
            PLAYER_SPEED: 6,
            BULLET_SPEED: 10,
            BULLET_INTERVAL: 150,
            PLAYER_MAX_HEALTH: 3,
            EVENT_COOLDOWN: 3000,
            POWERUP_SPAWN_RATE: 0.002,
            BOSS_FLASH_DISTANCE: 100,
            BOSS_RETREAT_DISTANCE: 30
        };

        // ============= å…¨å±€å˜é‡å£°æ˜ =============
        let gameState;
        let player;
        let boss;
        let bulletSystem;
        let eventSystem;
        let powerUpSystem;
        let inputManager;
        let renderer;
        let gameLoopId;

        // ============= æ¸¸æˆçŠ¶æ€ç®¡ç†å™¨ =============
        class GameState {
            constructor() {
                this.running = false;
                this.score = 0;
                this.startTime = 0;
                this.gameOverReason = '';
            }

            reset() {
                this.running = true;
                this.score = 0;
                this.startTime = Date.now();
                this.gameOverReason = '';
            }

            addScore(points) {
                this.score += points;
                document.getElementById('score').textContent = this.score;
            }

            endGame(reason) {
                this.running = false;
                this.gameOverReason = reason;
                if (gameLoopId) {
                    cancelAnimationFrame(gameLoopId);
                }
                setTimeout(() => this.showGameOver(), 500);
            }

            showGameOver() {
                document.getElementById('gameOverReason').textContent = this.gameOverReason;
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('gameOver').style.display = 'block';
            }
        }

        // ============= ç©å®¶ç³»ç»Ÿ =============
        const playerImage = new Image();
        playerImage.src = './images/FireN.PNG';

        const playerImagePower = new Image();
        playerImagePower.src = './images/FireY.PNG';
        
        class Player {
            constructor(canvas) {
                this.canvas = canvas;

                const playerDiv = document.getElementById('playerContainer');
                const rect = playerDiv.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();

                this.x = rect.left - canvasRect.left;
                this.y = rect.top - canvasRect.top;

                this.width = 100;
                this.height = 100;
                this.speed = CONFIG.PLAYER_SPEED;
                this.health = CONFIG.PLAYER_MAX_HEALTH;
                this.maxHealth = CONFIG.PLAYER_MAX_HEALTH;
                this.buffs = new Map();
                this.invulnerable = false;
            }

            update() {
                // æ›´æ–°ä½ç½®
                if (inputManager.leftPressed && this.x > 0) {
                    this.x -= this.speed;
                }
                if (inputManager.rightPressed && this.x < this.canvas.width - this.width) {
                    this.x += this.speed;
                }

                // æ›´æ–°Buff
                this.updateBuffs();

                // è¾¹ç•Œæ£€æŸ¥
                this.x = Math.max(0, Math.min(this.canvas.width - this.width, this.x));
            }

            updateBuffs() {
                const now = Date.now();
                for (let [type, endTime] of this.buffs) {
                    if (now > endTime) {
                        this.buffs.delete(type);
                    }
                }
                this.updateBuffUI();
            }

            updateBuffUI() {
                const buffIcons = document.getElementById('buffIcons');
                buffIcons.innerHTML = '';
                for (let [type, endTime] of this.buffs) {
                    const icon = document.createElement('div');
                    icon.className = 'buff';
                    icon.style.background = this.getBuffColor(type);
                    icon.textContent = this.getBuffIcon(type);
                    buffIcons.appendChild(icon);
                }
            }

            getBuffColor(type) {
                const colors = {
                    'shield': '#4444ff',
                    'power': '#ff4444',
                    'homing': '#44ff44'
                };
                return colors[type] || '#666';
            }

            getBuffIcon(type) {
                const icons = {
                    'shield': 'ğŸ›¡',
                    'power': 'âš¡',
                    'homing': 'ğŸ¯'
                };
                return icons[type] || '?';
            }

            takeDamage(amount = 1) {
                if (this.invulnerable || this.buffs.has('shield')) {
                    return false;
                }

                this.health -= amount;
                this.updateHealthUI();

                // çŸ­æš‚æ— æ•Œæ—¶é—´
                this.invulnerable = true;
                setTimeout(() => this.invulnerable = false, 500);

                if (this.health <= 0) {
                    gameState.endGame('Weapon Destroyedï¼');
                    return true;
                }
                return false;
            }

            heal(amount = 1) {
                this.health = Math.min(this.maxHealth, this.health + amount);
                this.updateHealthUI();
            }

            addBuff(type, duration) {
                this.buffs.set(type, Date.now() + duration);
            }

            updateHealthUI() {
                const bloodImage = document.getElementById('bloodImage');

                if (!bloodImage) return;

                const clampedHealth = Math.max(0, Math.min(this.health, this.maxHealth)); // é˜²æ­¢è¶Šç•Œ
                bloodImage.src = `./images/Blood${clampedHealth}.PNG`;
            }

render(ctx) {
   if (this.invulnerable && Date.now() % 200 < 100) {
       ctx.globalAlpha = 0.5;
   }

   // æ ¹æ®powerçŠ¶æ€é€‰æ‹©é¢„åŠ è½½çš„å›¾åƒ
   const currentImage = this.buffs.has('power') ? playerImagePower : playerImage;

   // æŠ¤ç›¾æ•ˆæœ - åœ¨ç©å®¶å›¾åƒä¸‹æ–¹ç»˜åˆ¶
   if (this.buffs.has('shield')) {
       const centerX = this.x + this.width / 2;
       const centerY = this.y + this.height / 1.5;
       const shieldRadius = Math.max(this.width, this.height) / 2 + 13;

       ctx.beginPath();
       ctx.arc(centerX, centerY, shieldRadius, 0, Math.PI * 2);
       ctx.strokeStyle = 'rgba(135, 206, 250, 0.8)';
       ctx.lineWidth = 2;
       ctx.stroke();
   }

   // ç»˜åˆ¶ç©å®¶å›¾åƒ
   if (playerImage.complete) {
       ctx.drawImage(playerImage, this.x, this.y, this.width, this.height);
   } else {
       ctx.fillStyle = '#00FF00'; // å¤‡ç”¨ç»¿è‰²æ–¹å—
       ctx.fillRect(this.x, this.y, this.width, this.height);
   }

   ctx.globalAlpha = 1;
}

        }

        // ============= Bossç³»ç»Ÿ =============
        const bossImage = new Image();
        bossImage.src = './images/BOSS.PNG';

        class Boss {

            constructor(canvas) {
                this.canvas = canvas;
                const bossDiv = document.getElementById('bossContainer');
                const rect = bossDiv.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();

                this.x = rect.left - canvasRect.left;
                this.y = rect.top - canvasRect.top;

                this.width = 100;
                this.height = 100;
                this.targetY = canvas.height;  // Bossæœ€ç»ˆä½ç½®
                this.speed = this.calculateSpeed();
            }

            calculateSpeed() {
                // æ ¹æ®æ¸¸æˆæ—¶é•¿è®¡ç®—Bossä¸‹é™é€Ÿåº¦
                const distance = this.targetY - this.y;
                return distance / (CONFIG.GAME_DURATION / 16.67); // 60fps
            }

            update() {
                if (this.y < this.targetY) {
                    this.y += this.speed;

                    // Bossåˆ°è¾¾ç©å®¶ä½ç½®
                    if (this.y >= this.targetY) {
                        gameState.endGame('Game Over!');
                    }
                }
            }

            flash() {
                // Bossé—ªç°åˆ°éšæœºä½ç½®
                const minX = this.width;
                const maxX = this.canvas.width - this.width * 2;
                this.x = Math.random() * (maxX - minX) + minX;

                // é—ªç°ç‰¹æ•ˆ
                renderer.addEffect({
                    type: 'flash',
                    x: this.x + this.width / 2,
                    y: this.y + this.height / 2,
                    duration: 500,
                    color: 'rgba(0, 0, 0, 0.5)'
                });
            }


            render(ctx) {
                if (bossImage.complete) {
                    ctx.drawImage(bossImage, this.x, this.y, this.width, this.height);
                } else {
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }

            }

        }

        // ============= å­å¼¹ç³»ç»Ÿ =============
        class BulletSystem {
            constructor() {
                this.bullets = [];
                this.lastFireTime = 0;
                this.powerBulletImg = new Image();
                this.powerBulletImg.src = './images/BuffPowerNow.PNG';
                this.fireworkTriggered = false;
            }

            update(player, boss) {
                const isPower = player.buffs.has('power');


                const now = Date.now();

                // è‡ªåŠ¨å‘å°„
                const interval = isPower ? CONFIG.BULLET_INTERVAL * 1.5 : CONFIG.BULLET_INTERVAL;

                if (now - this.lastFireTime > interval) {
                    this.fire(player, boss);
                    this.lastFireTime = now;
                }


                // æ›´æ–°å­å¼¹
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];

                    if (player.buffs.has('homing')) {
                        // åˆ¶å¯¼å¼¹è¯
                        const dx = (boss.x + boss.width/2) - (bullet.x + bullet.width/2);
                        const dy = (boss.y + boss.height/2) - (bullet.y + bullet.height/2);
                        const distance = Math.sqrt(dx*dx + dy*dy);

                        if (distance > 0) {
                            bullet.vx = (dx / distance) * bullet.speed * 0.3;
                            bullet.vy = (dy / distance) * bullet.speed;
                        }

                        bullet.x += bullet.vx;
                        bullet.y += bullet.vy;
                    } else {
                        bullet.y -= bullet.speed;
                    }

                    // ç§»é™¤å±å¹•å¤–çš„å­å¼¹
                    if (bullet.y < -10 || bullet.x < -10 || bullet.x > this.canvas?.width + 10) {
                        this.bullets.splice(i, 1);
                        continue;
                    }

                    // ç¢°æ’æ£€æµ‹
                    if (this.checkCollision(bullet, boss)) {
                        this.bullets.splice(i, 1);

                        const damage = isPower ? 50 : 10;
                        gameState.addScore(damage);


                        if (this.checkCollision(bullet, boss)) {
                            this.bullets.splice(i, 1);

                            const damage = isPower ? 100 : 10;
                            gameState.addScore(damage);

                            renderer.addEffect({
                                type: 'hit',
                                x: bullet.x,
                                y: bullet.y,
                                duration: 200
                            });

                            if (isPower) {
                                const fireworkX = Math.random() * (this.canvas?.width || 800);
                                const fireworkY = Math.random() * (this.canvas?.height || 600);

                                for (let i = 0; i < 3; i++) {
                                    setTimeout(() => {
                                        renderer.addEffect({
                                            type: 'firework',
                                            x: fireworkX,
                                            y: fireworkY,
                                            duration: 1000
                                        });
                                    }, i * 100); //
                                }
                            }
                        }

                        renderer.addEffect({
                            type: 'hit',
                            x: bullet.x,
                            y: bullet.y,
                            duration: 200
                        });


                }

                }
            }

            fire(player, boss) {
                const isPower = player.buffs.has('power');

                const bullet = {
                    x: player.x + player.width / 2 - (isPower ? 6 : 2), // ä¿è¯ä¸¤ç§å­å¼¹éƒ½å±…ä¸­
                    y: player.y,
                    width: isPower ? 40 : 4,
                    height: isPower ? 40 : 12,
                    speed: isPower ? CONFIG.BULLET_SPEED * 0.2 : CONFIG.BULLET_SPEED,
                    vx: 0,
                    vy: isPower ? -CONFIG.BULLET_SPEED * 0.2 : -CONFIG.BULLET_SPEED,
                    power: isPower, // æ ‡è®°powerå­å¼¹ï¼Œæ–¹ä¾¿æ¸²æŸ“å’Œé€»è¾‘
                    image: isPower ? this.powerBulletImg : null
                };

                this.bullets.push(bullet);
            }



            checkCollision(bullet, boss) {
                return bullet.x < boss.x + boss.width &&
                       bullet.x + bullet.width > boss.x &&
                       bullet.y < boss.y + boss.height &&
                       bullet.y + bullet.height > boss.y;
            }

            render(ctx) {
                this.bullets.forEach(bullet => {
                    if (bullet.power && bullet.image && bullet.image.complete) {
                        ctx.drawImage(bullet.image, bullet.x, bullet.y, bullet.width, bullet.height);
                    } else {
                        ctx.fillStyle = '#FFFF00';
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                    }
                });
            }


        }

        // ============= äº‹ä»¶ç³»ç»Ÿ =============
        class EventSystem {
            constructor() {
                this.events = {
                    flash: { ready: false, cooldown: Date.now() + 3000, maxCooldown: 15000 }, // 10ç§’åæ‰èƒ½å‘åŠ¨
                    spike: { ready: false, cooldown: Date.now() + 15000, maxCooldown: 10000 }, // 15ç§’å
                    projectile: { ready: false, cooldown: Date.now() + 5000, maxCooldown: 5000 } // 5ç§’å
                };


                this.activeSpikes = [];
                this.activeProjectiles = [];

                this.spikeImg = new Image();
                this.spikeImg.src = './images/Spike.PNG';

                this.spikeWarnImg = new Image();
                this.spikeWarnImg.src = './images/Spike.PNG';

                this.projectileImg = new Image();
                this.projectileImg.src = './images/Projectile.PNG';
            }

            update(player, boss) {
                this.updateCooldowns();
                this.updateActiveEvents(player);
                this.triggerRandomEvent(player, boss);
            }

            updateCooldowns() {
                const now = Date.now();
                for (let [type, event] of Object.entries(this.events)) {
                    if (!event.ready && now > event.cooldown) {
                        event.ready = true;
                        this.updateEventUI(type);
                    } else if (!event.ready) {
                        this.updateEventUI(type);
                    }
                }
            }


            updateActiveEvents(player) {
                // æ›´æ–°åœ°åˆºï¼ˆæ”¯æŒåå¤åˆºï¼‰
                for (let i = this.activeSpikes.length - 1; i >= 0; i--) {
                    const spike = this.activeSpikes[i];
                    if (Date.now() > spike.endTime) {
                        this.activeSpikes.splice(i, 1);
                    } else {
                        if (spike.active) {
                            // åå¤åˆºé€»è¾‘ï¼ˆæ­£å¼¦æ³¢æ¨¡æ‹Ÿï¼‰
                            const elapsed = Date.now() - spike.startActiveTime;
                            const phase = (elapsed % spike.cycleTime) / spike.cycleTime; // 0~1
                            const offset = Math.sin(phase * Math.PI * 2) * spike.maxOffset;
                            spike.currentY = spike.baseY - offset;

                            if (this.checkPlayerCollision(player, spike, spike.currentY)) {
                                player.takeDamage();
                            }
                        }
                    }
                }

                // æ›´æ–°æŠ•å°„ç‰©
                for (let i = this.activeProjectiles.length - 1; i >= 0; i--) {
                    const proj = this.activeProjectiles[i];

                    proj.x += proj.vx;
                    proj.y += proj.vy;


                    // åˆ é™¤æŠ•å°„ç‰©
                    if (proj.x < -50 || proj.x > canvas.width + 50 || proj.y < -50 || proj.y > canvas.height + 50) {
                        this.activeProjectiles.splice(i, 1);
                    } else if (this.checkPlayerCollision(player, proj)) {
                        player.takeDamage();
                        this.activeProjectiles.splice(i, 1);
                    }
                }
            }

            triggerRandomEvent(player, boss) {
                const readyEvents = Object.keys(this.events).filter(type => this.events[type].ready);
                if (readyEvents.length === 0 || Math.random() > 0.01) return;

                const eventType = readyEvents[Math.floor(Math.random() * readyEvents.length)];
                this.triggerEvent(eventType, player, boss);
            }

            triggerEvent(type, player, boss) {
                const event = this.events[type];
                event.ready = false;
                event.cooldown = Date.now() + event.maxCooldown;
                this.updateEventUI(type);

                switch (type) {
                    case 'flash': boss.flash(); break;
                    case 'spike': this.createSpike(player); break;
                    case 'projectile': this.createProjectile(player); break;
                }
            }


            createSpike(player) {
                const warningTime = 1000;
                const duration = 2000;

                const spike = {
                    x: player.x - 20,
                    baseY: player.y + player.height + 5,
                    width: player.width + 40,
                    height: 30,
                    active: false,
                    warning: true,
                    endTime: Date.now() + duration,
                    currentY: player.y + player.height + 5, // å½“å‰y
                    startActiveTime: 0,
                    cycleTime: 1000,
                    maxOffset: 15
                };

                setTimeout(() => {
                    spike.warning = false;
                    spike.active = true;
                    spike.startActiveTime = Date.now();
                }, warningTime);

                this.activeSpikes.push(spike);
            }
            createProjectile(player) {
                const startX = Math.random() * canvas.width;
                const startY = -30;

                const angle = Math.atan2(player.y - startY, player.x - startX);
                const speed = 4;

                const proj = {
                    x: startX,
                    y: startY,
                    width: 40,
                    height: 40,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    hasBounced: false
                };

                this.activeProjectiles.push(proj);
            }
            checkPlayerCollision(player, obj, customY = null) {
                const y = customY !== null ? customY : obj.y;
                return player.x < obj.x + obj.width &&
                    player.x + player.width > obj.x &&
                    player.y < y + obj.height &&
                    player.y + player.height > y;
            }

        updateEventUI(type) {
            const element = document.getElementById(`event${type.charAt(0).toUpperCase() + type.slice(1)}`);
            if (!element) return;

            const mask = element.querySelector('.cooldown-mask');
            const event = this.events[type];

            if (event.ready) {
                element.classList.add('ready');
                if (mask) mask.style.height = '0%'; // æ— é®ç½©
            } else {
                element.classList.remove('ready');

                if (mask) {
                    const now = Date.now();
                    const remaining = Math.max(0, event.cooldown - now);
                    const percent = remaining / event.maxCooldown;
                    mask.style.height = `${Math.floor(percent * 100)}%`;
                }
            }
        }



            render(ctx) {
                // åœ°åˆºæ¸²æŸ“
                this.activeSpikes.forEach(spike => {
                    const drawY = spike.warning ? spike.baseY : spike.currentY;
                    ctx.globalAlpha = spike.warning ? 0.4 : 1.0;
                    ctx.drawImage(this.spikeWarnImg, spike.x, drawY, spike.width, spike.height);
                    ctx.globalAlpha = 1.0;
                });

                // æŠ•å°„ç‰©æ¸²æŸ“
                this.activeProjectiles.forEach(proj => {
                    ctx.drawImage(this.projectileImg, proj.x, proj.y, proj.width, proj.height);
                });
            }
        }

        // ============= é“å…·ç³»ç»Ÿ =============
        class PowerUpSystem {
            constructor() {
                this.powerUps = [];

                // é¢„åŠ è½½é“å…·å›¾ç‰‡
                this.images = {
                    'heal': new Image(),
                    'shield': new Image(),
                    'power': new Image(),
                    'homing': new Image()
                };

                this.images['heal'].src = './images/BuffHeal.PNG';
                this.images['shield'].src = './images/BuffShield.PNG';
                this.images['power'].src = './images/BuffPower.PNG';
                this.images['homing'].src = './images/BuffHoming.PNG';
            }

            update(player) {
                // ç”Ÿæˆé“å…·
                if (Math.random() < CONFIG.POWERUP_SPAWN_RATE) {
                    this.spawnPowerUp();
                }

                // æ›´æ–°é“å…·
                for (let i = this.powerUps.length - 1; i >= 0; i--) {
                    const powerUp = this.powerUps[i];
                    powerUp.y += 2;

                    // ç§»é™¤å±å¹•å¤–çš„é“å…·
                    if (powerUp.y > canvas.height + 20) {
                        this.powerUps.splice(i, 1);
                        continue;
                    }

                    // ç¢°æ’æ£€æµ‹
                    if (this.checkCollision(powerUp, player)) {
                        this.applyPowerUp(powerUp.type, player);
                        this.powerUps.splice(i, 1);
                    }
                }
            }

            spawnPowerUp() {
                const types = ['heal', 'shield', 'power', 'homing'];
                const type = types[Math.floor(Math.random() * types.length)];

                this.powerUps.push({
                    x: Math.random() * (canvas.width - 30),
                    y: -20,
                    width: 80,
                    height: 80,
                    type: type
                });
            }

            applyPowerUp(type, player) {
                switch(type) {
                    case 'heal':
                        player.heal();
                        break;
                    case 'shield':
                        player.addBuff('shield', 5000);
                        break;
                    case 'power':
                        player.addBuff('power', 8000);
                        break;
                    case 'homing':
                        player.addBuff('homing', 10000);
                        break;
                }

                // é“å…·è·å–ç‰¹æ•ˆ
                renderer.addEffect({
                    type: 'powerup',
                    x: player.x + player.width/2,
                    y: player.y + player.height/2,
                    duration: 500
                });
            }

            checkCollision(powerUp, player) {
                return powerUp.x < player.x + player.width &&
                       powerUp.x + powerUp.width > player.x &&
                       powerUp.y < player.y + player.height &&
                       powerUp.y + powerUp.height > player.y;
            }

            render(ctx) {
                this.powerUps.forEach(powerUp => {
                    const img = this.images[powerUp.type];
                    if (img.complete) {
                        ctx.drawImage(img, powerUp.x, powerUp.y, powerUp.width, powerUp.height);
                    } else {
                        // å›¾ç‰‡æœªåŠ è½½å®Œæˆæ—¶ï¼Œæ˜¾ç¤ºå ä½è‰²
                        ctx.fillStyle = '#888';
                        ctx.fillRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
                    }
                });
            }
        }

       // ============= è¾“å…¥ç®¡ç†å™¨ =============
       class InputManager {
           constructor() {
               this.leftPressed = false;
               this.rightPressed = false;
               this.setupEventListeners();
           }

           setupEventListeners() {
               // é”®ç›˜äº‹ä»¶
               document.addEventListener('keydown', (e) => {
                   if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
                       this.leftPressed = true;
                       e.preventDefault();
                   }
                   if (e.code === 'ArrowRight' || e.code === 'KeyD') {
                       this.rightPressed = true;
                       e.preventDefault();
                   }
               });

               document.addEventListener('keyup', (e) => {
                   if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
                       this.leftPressed = false;
                       e.preventDefault();
                   }
                   if (e.code === 'ArrowRight' || e.code === 'KeyD') {
                       this.rightPressed = false;
                       e.preventDefault();
                   }
               });

               // æŒ‰é’®æ§åˆ¶
               this.setupButtonControls();

               // è§¦æ‘¸æ§åˆ¶
               this.setupTouchControls();
           }

           setupButtonControls() {
               const leftBtn = document.getElementById('leftBtn');
               const rightBtn = document.getElementById('rightBtn');

               leftBtn.addEventListener('mousedown', () => this.leftPressed = true);
               leftBtn.addEventListener('mouseup', () => this.leftPressed = false);
               leftBtn.addEventListener('mouseleave', () => this.leftPressed = false);

               rightBtn.addEventListener('mousedown', () => this.rightPressed = true);
               rightBtn.addEventListener('mouseup', () => this.rightPressed = false);
               rightBtn.addEventListener('mouseleave', () => this.rightPressed = false);

               leftBtn.addEventListener('touchstart', (e) => {
                   e.preventDefault();
                   this.leftPressed = true;
               });
               leftBtn.addEventListener('touchend', (e) => {
                   e.preventDefault();
                   this.leftPressed = false;
               });

               rightBtn.addEventListener('touchstart', (e) => {
                   e.preventDefault();
                   this.rightPressed = true;
               });
               rightBtn.addEventListener('touchend', (e) => {
                   e.preventDefault();
                   this.rightPressed = false;
               });
           }

           setupTouchControls() {
               let touchStartX = 0;

               canvas.addEventListener('touchstart', (e) => {
                   e.preventDefault();
                   touchStartX = e.touches[0].clientX;
               });

               canvas.addEventListener('touchmove', (e) => {
                   e.preventDefault();
                   const touchX = e.touches[0].clientX;
                   const deltaX = touchX - touchStartX;

                   if (Math.abs(deltaX) > 20) {
                       if (deltaX > 0) {
                           this.rightPressed = true;
                           this.leftPressed = false;
                       } else {
                           this.leftPressed = true;
                           this.rightPressed = false;
                       }
                       touchStartX = touchX;
                   }
               });

               canvas.addEventListener('touchend', (e) => {
                   e.preventDefault();
                   this.leftPressed = false;
                   this.rightPressed = false;
               });
           }
       }

       // ============= æ¸²æŸ“å™¨ =============
       class Renderer {
           constructor(canvas) {
               this.canvas = canvas;
               this.ctx = canvas.getContext('2d');
               this.effects = [];
           }

           addEffect(effect) {
                effect.startTime = Date.now();

                if (effect.type === 'firework') {
                    const count = 50; // å‡å°‘ç²’å­æ•°é‡é¿å…æ€§èƒ½é—®é¢˜
                    effect.particles = [];
                    for (let i = 0; i < count; i++) {
                        const angle = (Math.PI * 2 * i) / count;
                        const speed = Math.random() * 3 + 1;
                        effect.particles.push({
                            x: effect.x,
                            y: effect.y,
                            radius: Math.random() * 2 + 1,
                            color: `hsl(${Math.random() * 360}, 100%, 70%)`,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            alpha: 1
                        });
                    }
                }

                this.effects.push(effect); // åªæ·»åŠ ä¸€æ¬¡
            }


           updateEffects() {
                const now = Date.now();

                this.effects = this.effects.filter(effect => {
                    const progress = (now - effect.startTime) / effect.duration;

                    if (effect.type === 'firework') {
                        effect.particles.forEach(p => {
                            p.x += p.vx;
                            p.y += p.vy;
                            p.vx *= 0.98; // æ·»åŠ é˜»åŠ›
                            p.vy *= 0.98;
                            p.alpha = Math.max(0, 1 - progress); // åŸºäºæ•´ä½“è¿›åº¦æ·¡å‡º
                        });
                    }

                    return progress < 1;
                });
            }


           renderEffects() {
               const now = Date.now();
               this.effects.forEach(effect => {
                   const progress = (now - effect.startTime) / effect.duration;
                   this.renderEffect(effect, progress);
               });
           }

           renderEffect(effect, progress) {
               this.ctx.save();

               switch(effect.type) {
                   case 'flash':
                       this.ctx.globalAlpha = 1 - progress;
                       this.ctx.fillStyle = '#ffffff';
                       this.ctx.beginPath();
                       this.ctx.arc(effect.x, effect.y, 50 * progress, 0, 2 * Math.PI);
                       this.ctx.fill();
                       break;

                   case 'hit':
                       this.ctx.globalAlpha = 1 - progress;
                       this.ctx.fillStyle = '#ffff00';
                       this.ctx.beginPath();
                       this.ctx.arc(effect.x, effect.y, 20 * progress, 0, 2 * Math.PI);
                       this.ctx.fill();
                       break;

                   case 'powerup':
                       this.ctx.globalAlpha = 1 - progress;
                       this.ctx.strokeStyle = '#00ff00';
                       this.ctx.lineWidth = 3;
                       this.ctx.beginPath();
                       this.ctx.arc(effect.x, effect.y, 30 * progress, 0, 2 * Math.PI);
                       this.ctx.stroke();
                       break;

                   case 'firework':
                        effect.particles.forEach(p => {
                            this.ctx.globalAlpha = p.alpha;
                            this.ctx.fillStyle = p.color;
                            this.ctx.beginPath();
                            this.ctx.arc(p.x, p.y, p.radius, 0, 2 * Math.PI);
                            this.ctx.fill();
                        });
                        break;

               }

               this.ctx.restore();
           }

           clear() {
               this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
           }

           render() {
               this.clear();

               // æ¸²æŸ“æ¸¸æˆå¯¹è±¡
               if (player) player.render(this.ctx);
               if (boss) boss.render(this.ctx);
               if (bulletSystem) bulletSystem.render(this.ctx);
               if (eventSystem) eventSystem.render(this.ctx);
               if (powerUpSystem) powerUpSystem.render(this.ctx);

               // æ¸²æŸ“ç‰¹æ•ˆ
               this.updateEffects();
               this.renderEffects();
           }
       }

       // ============= æ¸¸æˆåˆå§‹åŒ– =============
       const canvas = document.getElementById('gameCanvas');

       // ============= è®¾ç½®ç”»å¸ƒå¤§å° =============
       function resizeCanvas() {
           canvas.width = window.innerWidth;
           canvas.height = window.innerHeight;

           // é‡æ–°è®¡ç®—æ¸¸æˆå¯¹è±¡ä½ç½®
           if (player) {
               player.canvas = canvas;
               player.x = Math.min(player.x, canvas.width - player.width);
               player.y = canvas.height - 80;
           }

           if (boss) {
               boss.canvas = canvas;
               boss.targetY = canvas.height * 0.3;
               boss.speed = boss.calculateSpeed();
           }
       }

       // ============= æ¸¸æˆä¸»å¾ªç¯ =============
       function gameLoop() {
           if (!gameState || !gameState.running) return;

           try {
               // æ›´æ–°æ¸¸æˆç³»ç»Ÿ
               if (player) player.update();
               if (boss) boss.update();
               if (bulletSystem && player && boss) bulletSystem.update(player, boss);
               if (eventSystem && player && boss) eventSystem.update(player, boss);
               if (powerUpSystem && player) powerUpSystem.update(player);

               // æ¸²æŸ“
               if (renderer) renderer.render();

               gameLoopId = requestAnimationFrame(gameLoop);
           } catch (error) {
               console.error('Something Wrongâ€¦:', error);
               if (gameState) {
                   gameState.endGame('Errorâ€¦');
               }
           }
       }

       // ============= æ¸¸æˆæ§åˆ¶ =============
       function initGame() {
           // åˆå§‹åŒ–ç”»å¸ƒ
           resizeCanvas();
           window.addEventListener('resize', resizeCanvas);

           // åˆ›å»ºè¾“å…¥ç®¡ç†å™¨
           inputManager = new InputManager();

           // ç»‘å®šæŒ‰é’®äº‹ä»¶
           document.getElementById('startBtn').addEventListener('click', startGame);
           document.getElementById('restartBtn').addEventListener('click', restartGame);
       }
       function startGame() {
           // éšè—å¼€å§‹å¼¹çª—
           document.getElementById('gameStart').style.display = 'none';
           document.getElementById('gameOver').style.display = 'none';

           document.getElementById('bossContainer').style.opacity = '0';
            document.getElementById('playerContainer').style.opacity = '0';

           // é‡ç½®æ¸¸æˆçŠ¶æ€
           gameState = new GameState();
           gameState.reset();

           // é‡æ–°åˆ›å»ºæ‰€æœ‰æ¸¸æˆç³»ç»Ÿ
           player = new Player(canvas);
           boss = new Boss(canvas);
           bulletSystem = new BulletSystem();
           eventSystem = new EventSystem();
           powerUpSystem = new PowerUpSystem();
           renderer = new Renderer(canvas);

           // åˆå§‹åŒ–UI
           player.updateHealthUI();
           document.getElementById('score').textContent = '0';

           // åˆå§‹åŒ–äº‹ä»¶å›¾æ ‡
           eventSystem.updateEventUI('flash');
           eventSystem.updateEventUI('spike');
           eventSystem.updateEventUI('projectile');

           // å¼€å§‹æ¸¸æˆå¾ªç¯
           gameLoop();

           console.log('Startï¼');
       }
       function restartGame() {
           // åœæ­¢å½“å‰æ¸¸æˆå¾ªç¯
           if (gameLoopId) {
               cancelAnimationFrame(gameLoopId);
           }

           // é‡æ–°å¼€å§‹æ¸¸æˆ
           startGame();
       }

       // ============= é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ– =============
       document.addEventListener('DOMContentLoaded', function() {
           console.log('é¡µé¢åŠ è½½å®Œæˆï¼Œåˆå§‹åŒ–æ¸¸æˆ...');
           initGame();
       });

       // é˜²æ­¢é¡µé¢æ»šåŠ¨
       document.addEventListener('touchmove', function(e) {
           e.preventDefault();
       }, { passive: false });

       // é˜²æ­¢åŒå‡»ç¼©æ”¾
       document.addEventListener('dblclick', function(e) {
           e.preventDefault();
       });
   </script>
</body>
</html>
